
-------------------------- MODULE AlphaInterface ----------------------------
(***************************************************************************)
(* This module describes the interface between the Alpha Memory System and  *)
(* its environment, which is a collection of processors.  The environment   *)
(* interacts with the system by sending requests to which the system        *)
(* responds.  We represent the interface by the declared variable aInt.     *)
(* The sending of a request or a response is represented by a change to     *)
(* the value of aInt.  We don't describe how the interface is implemented.  *)
(* Instead, we declare two unspecified constant operators RequestFromEnv    *)
(* and ResponseToEnv and describe the changes to aInt in terms of them.     *)
(* The action                                                               *)
(*                                                                          *)
(*    RequestFromEnv(aInt, aInt', p, r)                                     *)
(*                                                                          *)
(* represents the environment sending a request r for processor p, and      *)
(* the action                                                               *)
(*                                                                          *)
(*    ResponseToEnv(aInt, aInt', p, r)                                      *)
(*                                                                          *)
(* represents the system responding to processor p with a response r.       *)
(* (An action is a formula that describes a change of state, where          *)
(* unprimed occurrence of a variable denotes it value in the old state,     *)
(* and a primed occurrence denotes its value in the new state.)             *)
(*                                                                          *)
(* There are a number of assumptions we could make to assert that these     *)
(* actions actually are reasonable representations of what we expect--for   *)
(* example, that they change aInt (so they are nonstuttering actions).      *)
(* However, the correctness of the implementation doesn't depend on these   *)
(* assumptions, since the identical actions will appear in the              *)
(* specifications of both the memory model and of the Wildfire protocol.    *)
(* So, we won't bother asserting any such assumptions.                      *)
(***************************************************************************)

EXTENDS Naturals, FiniteSets
  (*************************************************************************)
  (* This statement imports the definitions from the modules Naturals and  *)
  (* FiniteSets.  The Naturals module defines the set Nat of natural       *)
  (* numbers and the usual operators like +, *, and ^.  It also defines    *)
  (* i..j to be the set of naturals from i through j.  It is defined by    *)
  (*                                                                       *)
  (*    i..j == {n \in Nat : (i \leq n) /\ (n \leq j)}                     *)
  (*                                                                       *)
  (* so it is the empty set if i < j.                                      *)
  (*                                                                       *)
  (* The FiniteSets module defines IsFiniteSet(S) to be true iff S is a    *)
  (* finite set, and Cardinality(S) to be the number of elements in the    *)
  (* finite set S.                                                         *)
  (*************************************************************************)

VARIABLE aInt
  (*************************************************************************)
  (* A variable is a nonconstant parameter--that is, it is part of the     *)
  (* system's state, which changes in the course of a behavior.            *)
  (*************************************************************************)

(***************************************************************************)
(*                          CONSTANT PARAMETERS                            *)
(*                                                                         *)
(* The following statement declares the constant parameters of the         *)
(* specification.  Parameters are the "free variables" of a spec.          *)
(***************************************************************************)
CONSTANTS
  RequestFromEnv(_, _, _, _),
  ResponseToEnv(_, _, _, _),
  Proc,
    (***********************************************************************)
    (* The set of processor identifiers.  We will usually use the term     *)
    (* "processor" to mean an element of Proc--that is, a processor        *)
    (* identifier.                                                         *)
    (***********************************************************************)
  Adr,
    (***********************************************************************)
    (* A memory associates data values with addresses.  Adr is the set of  *)
    (* all memory addresses.                                               *)
    (***********************************************************************)
  DataLen
    (***********************************************************************)
    (* The number of bits of data in a data value.  That is, each memory   *)
    (* location contains DataLen bits of data.                             *)
    (***********************************************************************)

ASSUME
  (*************************************************************************)
  (* This ASSUME statement asserts an assumption that we make about the    *)
  (* constant parameters declared above.                                   *)
  (*************************************************************************)
  /\ IsFiniteSet(Proc)
     (**********************************************************************)
     (* We assume that there are a finite number of processors.  We don't  *)
     (* state any assumption about the cardinality of Adr because we don't *)
     (* believe that correctness of the protocol depends on it.            *)
     (**********************************************************************)
  /\ (DataLen \in Nat) /\ (DataLen > 0)
     (**********************************************************************)
     (* Asserts that DataLen has the right "type".                         *)
     (**********************************************************************)

Data == [0..(DataLen - 1) -> {0,1}]
  (*************************************************************************)
  (* This statement defines Data to be the the set of all data values,     *)
  (* where a data value is a bit string of length DataLen.  We represent a *)
  (* bit string of length s to be a function f, where f[0], f[1], ... ,    *)
  (* f[s-1] are the values of the individual bits.                         *)
  (*                                                                       *)
  (* In TLA+, [S -> T] is the set of all functions from S to T.  Recall    *)
  (* that the operator .. is defined in the Naturals module.               *)
  (*************************************************************************)

-----------------------------------------------------------------------------
(***************************************************************************)
(*                     Requests and Responses                              *)
(*                                                                         *)
(* In our model of the Alpha memory, a processor can issue five            *)
(* different kinds of requests, which have the following                   *)
(* intuitive meanings:                                                     *)
(*                                                                         *)
(*   Rd : Read a memory address.  The memory responds with a data value.   *)
(*                                                                         *)
(*   Wr : Write a memory address through a mask.  An address in our model  *)
(*        represents a complete cache line.  We represent the write of a   *)
(*        part of the cache line by a masked write, which changes only the *)
(*        bits for which the corresponding mask bit equals 1.  The         *)
(*        memory responds with an acknowledgement that the write has       *)
(*        been performed.                                                  *)
(*                                                                         *)
(*   LL : Load locked.  This is a read of a memory address that "locks"    *)
(*        the address for the processor, unlocking any other address that  *)
(*        might be locked for the processor.  The memory responds with a   *)
(*        data value.                                                      *)
(*                                                                         *)
(*   SC : Store conditional.  This is a conditional masked write           *)
(*        operation--that is, it may succeed or fail.  The write succeeds  *)
(*        if the specified address is locked, otherwise it fails and       *)
(*        leaves the memory unchanged.  An SC (successful or not) unlocks  *)
(*        any memory address locked by the processor.  A memory address is *)
(*        also unlocked when a DIFFERENT processor performs a Wr or        *)
(*        successful SC to an address locked by the processor.  The memory *)
(*        responds to an SC with an acknowledgement indicating whether or  *)
(*        not the request succeeded.                                       *)
(*                                                                         *)
(*   MB : Memory barrier.  Two requests from the same processor to the     *)
(*        same address must always be performed in the order in which they *)
(*        were requested.  Two requests to different addresses from the    *)
(*        same processor must be performed in the order they were          *)
(*        requested if an MB request was issued after the first and before *)
(*        the second.  The memory does not respond to an MB request.       *)
(*                                                                         *)
(* A request or a response is represented by a record.  Here are the       *)
(* meanings of the different fields in the record.                         *)
(*                                                                         *)
(*   type    : The type of request.  A response to an SC that failed has   *)
(*             this field equal to "FailedSC".                             *)
(*   adr     : The memory address.                                         *)
(*   data    : The data to be written or that has been read.               *)
(*   mask    : The mask value for a Wr or SC.                              *)
(*                                                                         *)
(* In TLA+, [f1 : S1, ...  , fn : Sn] is the set of all records whose fi   *)
(* field is an element of the set Si, for i = 1, ... , n.                  *)
(***************************************************************************)
Request ==
  (*************************************************************************)
  (* The set of all requests.  In TLA+, \cup is ordinary set union.        *)
  (*************************************************************************)
       [type : {"MB"}]
  \cup [type : {"Rd", "LL"}, adr : Adr]
  \cup [type : {"Wr", "SC"}, adr : Adr, mask : Data, data : Data]

Response ==
  (*************************************************************************)
  (* The set of all responses.                                             *)
  (*************************************************************************)
       [type : {"Rd", "LL"}, adr : Adr, data : Data]
  \cup [type : {"Wr", "SC", "FailedSC"},  adr : Adr]
=============================================================================
Last modified on Mon Jun 12 17:19:07 PDT 2000 by lamport 
